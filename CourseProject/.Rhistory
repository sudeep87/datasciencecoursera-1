# calculate the mean and add it to vector of means
sample_means <- c(sample_means,mean(sample))
}
# calculate the mean of means (which should converge on population mean),
# and standard error (s.d. of sample means), which -> 0 as sample_size gets larger
mean_sample_means <- mean(sample_means)
std_error <- sqrt(var(sample_means)) / sqrt(sample_size)
# draw histogram with superimposed empirical density curve
p0 = qplot(sample_means, geom='blank') +
geom_histogram(aes(y = ..density..), colour="black", fill="lightblue",binwidth=.002) +
geom_line(aes(y = ..density.., colour = 'Empirical'), stat = 'density') +
stat_function(fun = dnorm, aes(colour = 'Normal')) +
geom_vline(xintercept=0.50,colour="darkgreen") +
scale_colour_manual(name = 'Density', values = c('red','blue')) +
# theme_bw() +
theme(legend.position = c(0.85, 0.85)) +
labs(title="Distribution of Sample Means\n",
x = "\nSample Means",
y = "Density")
# overlay histogram, empirical density and normal density
#   p0 = qplot(sample_means, geom = 'blank') +
#       geom_line(aes(y = ..density.., colour = 'Empirical'), stat = 'density') +
#       stat_function(fun = dnorm, aes(colour = 'Normal')) +
#       geom_histogram(aes(y = ..density..), alpha = 0.4, colour = "black", fill = "orange") +
#       scale_colour_manual(name = 'Density', values = c('red', 'blue')) +
#       theme(legend.position = c(0.85, 0.85)) +
#       labs(title="Distribution of Sample Means\n",
#            x = "\nSample Means",
#            y = "Density")
#
return(p0)
}
flipCoins(10000,2000,1000)
# create some data to work with
library(ggplot2)
x = rnorm(1000);
# overlay histogram, empirical density and normal density
p0 = qplot(x, geom = 'blank') +
geom_line(aes(y = ..density.., colour = 'Empirical'), stat = 'density') +
stat_function(fun = dnorm, aes(colour = 'Normal')) +
geom_histogram(aes(y = ..density..), alpha = 0.4, colour = "black", fill = "orange") +
scale_colour_manual(name = 'Density', values = c('red', 'blue'))
+ opts(legend.position = c(0.85, 0.85))
print(p0)
n <- 100
rolls <- sample(1:6,n,replace=TRUE)
roll_count <- 1:n
means <- cumsum(rolls)/1:n
plot(means,roll_count)
type="l")
plot(roll_count,
means,
type="l")
?lines
?hline
?hlines
?abline
abline(3.5,1,col="blue")
abline(3.5,0,col="blue")
plot(roll_count,
means,
type="l")
abline(3.5,0,col="blue")
plot(roll_count,
means,
type="l",
ylim=c(0,6))
abline(3.5,0,col="blue")
plot(log10(roll_count),
means,
type="l",
ylim=c(0,6))
abline(3.5,0,col="blue")
n <- 100000
rolls <- sample(1:6,n,replace=TRUE)
roll_count <- 1:n
means <- cumsum(rolls)/1:n
hist(rolls,
col="cadetblue1",
breaks=0:6)
table(rolls)
library(psych)
describe(rolls)
plot(log10(roll_count),
means,
type="l",
ylim=c(0,6))
abline(3.5,0,col="blue")
?for
sds <- replicate(null,n)
?replicate
?repeat
for (i in 1:n ) {
sds[ifoo.squared[i] = foo[i]^2
}
hist(rolls,
col="cadetblue1",
breaks=0:6)
?repeat
sds <- rep(NA, n))
for (i in 1:n ) {
sds[i] = sd(rolls[1:i])
}
sds <- rep(NA, n))
sds <- rep(NA, n)
for (i in 1:n ) {
sds[i] = sd(rolls[1:i])
}
sds
hist(rolls,
col="cadetblue1",
breaks=0:6)
table(rolls)
library(psych)
describe(rolls)
plot(log10(roll_count),
means,
type="l",
ylim=c(0,6))
lines(log10(roll_count),
sds,
col="green")
abline(3.5,0,col="blue")
abline(35/12,0,col="purple")
abline(sqrt(35/12),0,col="purple")
plot(log10(roll_count),
means,
type="l",
ylim=c(0,6))
lines(log10(roll_count),
sds,
col="green")
abline(3.5,0,col="blue")
abline(sqrt(35/12),0,col="purple")
sds <- rep(NA, n)
for (i in 1:n ) {
sds[i] = sd(rolls[1:i])
}
install.packages("ggviz")
install.packages("ggvis")
mtcars %>% ggvis(~wt, ~mpg) %>% layer_points()
library(ggvis)
library(dplyr)
mtcars %>% ggvis(~wt, ~mpg) %>% layer_points()
mtcars %>%
ggvis(~wt, ~mpg) %>%
layer_points(size := 25, shape := "diamond", stroke := "red", fill := NA)
mtcars %>%
ggvis(~wt, ~mpg) %>%
layer_points() %>%
layer_smooths()
mtcars %>%
ggvis(~wt, ~mpg) %>%
layer_points() %>%
layer_model_predictions(model = "lm", se = TRUE)
mtcars %>%
ggvis(~wt, ~mpg) %>%
layer_points(fill = ~factor(cyl))
mtcars %>%
ggvis(~wt, ~mpg, fill = ~factor(cyl)) %>%
layer_points() %>%
group_by(cyl) %>%
layer_model_predictions(model = "lm")
library(ggvis)
library(dplyr)
mtcars %>% ggvis(~wt, ~mpg) %>% layer_points()
mtcars %>%
ggvis(~wt, ~mpg) %>%
mtcars %>%
ggvis(~wt, ~mpg) %>%
layer_points()
mtcars %>%
ggvis(~wt, ~mpg) %>%
layer_points()
mtcars %>%
ggvis(~wt, ~mpg) %>%
layer_points(size := 25, shape := "diamond", stroke := "red", fill := NA)
mtcars %>%
ggvis(~wt, ~mpg) %>%
layer_points() %>%
layer_smooths()
mtcars %>%
ggvis(~wt, ~mpg) %>%
layer_points() %>%
layer_model_predictions(model = "lm", se = TRUE)
mtcars %>%
ggvis(~wt, ~mpg) %>%
layer_points(fill = ~factor(cyl))
mtcars %>%
ggvis(~wt, ~mpg, fill = ~factor(cyl)) %>%
layer_points() %>%
group_by(cyl) %>%
layer_model_predictions(model = "lm")
mtcars %>%
ggvis(~wt, ~mpg, fill = ~factor(cyl)) %>%
layer_points() %>%
group_by(cyl) %>%
layer_model_predictions(model = "lm")
mtcars %>%
ggvis(~wt, ~mpg) %>%
layer_points() %>%
layer_model_predictions(model = "lm", se = TRUE)
install.packages(c("digest", "httr", "jsonlite", "knitr", "lazyeval", "manipulate", "mgcv", "RColorBrewer", "RCurl", "reshape2", "rmarkdown"))
install.packages(c("digest", "httr", "jsonlite", "knitr", "lazyeval",
install.packages(c("digest", "httr", "jsonlite", "knitr", "lazyeval", "manipulate", "mgcv", "RColorBrewer", "RCurl", "reshape2", "rmarkdown"))
perm <- function(n,k){choose(n,k) * factorial(k)}
perm(500,2)
perm(5000,2)
perm(50000,2)
choose(52,2)
factorial(52)/(factorial(2) * factorial(50))
choose(52,5)
choose(52,6)
choose(52,7)
52 * choose(4,2)
52 * choose(4,3)
52 * choose(4,4)
choose(4,2)
choose(4,3) # sets
choose(4,4) # quads
52 * choose(4,2)
52 * choose(4,3)
52 * choose(4,4)
52 * choose(4,2) * choose(52 - 4, 5)
52 * choose(4,3) * choose(52 - 4, 4)
52 * choose(4,4) * choose(52 - 4, 3)
(52 * choose(4,2) * choose(52 - 4, 5))/choose(52,7)
(52 * choose(4,3) * choose(52 - 4, 4))/choose(52,7)
(52 * choose(4,4) * choose(52 - 4, 3))/choose(52,7)
choose(52,7)
52 * choose(4,4) * choose(52 - 4, 3)
(52 * choose(4,4) * choose(52 - 4, 3))/choose(52,7)
(52 * choose(4,3) * choose(52 - 4, 4))/choose(52,7)
52 * choose(4,3)
52 * choose(4,2) * choose(52 - 4, 5)
52 * choose(4,3) * choose(52 - 4, 4)
(52 * choose(4,2) * choose(52 - 4, 5))/choose(52,7)
(52 * choose(4,3) * choose(52 - 4, 4))/choose(52,7)
(52 * choose(4,4) * choose(52 - 4, 3))/choose(52,7)
52 * choose(4,3) * choose(52 - 4, 4)
52 * choose(4,4) * choose(52 - 4, 3)
52 * choose(4,2) * choose(52 - 4, 5)
534238848 / 133784560
52 * choose(4,2) * choose(52 - 2, 5)
(52 * choose(4,2) * choose(52 - 2, 5))/choose(52,7)
(52 * choose(4,3) * choose(52 - 3, 4))/choose(52,7)
(52 * choose(4,4) * choose(52 - 4, 3))/choose(52,7)
(52 * choose(4,2) * choose(52 - 2, 5))/choose(52,7)
(52 * choose(4,3) * choose(52 - 3, 4))/choose(52,7)
(52 * choose(4,4) * choose(52 - 4, 3))/choose(52,7)
nsamp(4,2,ordered=T)
install.packages("prob")
nsamp(4,2,ordered=T)
library(prob)
nsamp(4,2,ordered=T)
nsamp(52,2,ordered=T)
nsamp(52,2,ordered=F)
nsamp(5000,2,ordered=F)
nsamp(50000,2,ordered=F)
perm(50000,2)
library(swirl)
swirl()
plot(child ~ parent, galton)
plot(jitter(child,4) ~ parent,galton)
regrline <- lm(child ~ parent,galton)
abline(regrline,lwd=3,col='red')
summary(regrline)
data(mtcars)
summary(mtcars)
plot(jitter(child,4) ~ parent,mtcars)
plot(mpg ~ disp, mtcars)
plot(jitter(mpg,4) ~ disp, mtcars)
regrline <- lm(mpg ~ disp, mtcars)
abline(regrline,lwd=3,col='red')
summary(regrline)
?abline
abline(0,1,lwd=3,col='purple')
plot(jitter(mpg,4) ~ disp, mtcars)
regrline <- lm(mpg ~ disp, mtcars)
abline(regrline,lwd=3,col='red')
abline(0,1,lwd=3,col='purple')
abline(1,0,lwd=3,col='purple')
?abline
abline(h=mean(mpg),v=mean(disp),lwd=3,col='purple')
abline(h=mean(mtcars$mpg),v=mean(mtcars$disp),lwd=3,col='purple')
lwd=1,
col='purple')
abline(h=mean(mtcars$mpg),
v=mean(mtcars$disp),
lwd=1,
col='purple')
plot(jitter(mpg,4) ~ disp, mtcars)
regrline <- lm(mpg ~ disp, mtcars)
abline(regrline,lwd=3,col='red')
abline(h=mean(mtcars$mpg),
v=mean(mtcars$disp),
lwd=1,
col='purple')
plot(mpg ~ disp, mtcars)
# if a lot of points have identical coordinates, use jitter
plot(jitter(mpg,4) ~ disp, mtcars)
plot(mpg ~ disp, mtcars)
plot(jitter(mpg,4) ~ disp, mtcars)
regrline <- lm(mpg ~ disp, mtcars)
abline(regrline,lwd=3,col='red')
abline(h=mean(mtcars$mpg),
v=mean(mtcars$disp),
lwd=1,
col='purple')
choose(91,12)
choose(91,12) * (78/91)^12
(78/91)^12
(78 / 91)^12
choose(12,91)
?choose
78 / 91
(78/91)^12
choose(91,12)
choose(91,12) * ((78/91)^12)
?dbinom
choose(91,12)
(78 / 91)^12
pbinom(91,12,78/91)
# LOLN2.R
# LOLN.R
library(ggplot2)
library(scales)
# function to roll dice and calculate cumulative average roll
tossCoin <- function(n=30) {
# create a vector of index numbers
index <- c(1:n)
# create a vector of outcomes (H/T are coded using 0/1)
outcomes <- c(0,1) # sample space
# set seed value if you want repeatable results
# set.seed(1000200300)
# create a random sample of n flips
flips <- sample(outcomes,n,replace=T)
# now create a cumulative mean vector
cum_mean <- cumsum(flips)/(1:n)
# now combine the index, flips and cum_mean vectors
# into a data frame and return it
return(data.frame(index,flips,cum_mean))
}
ggplotCoinTosses <- function(n=30) {
# visualize how cumulative average converges on 7
# roll the dice n times and calculate means
trial1 <- tossCoin(n)
max_y <- ceiling(max(trial1$cum_mean))
if (max_y < .75) max_y = .75
min_y <- floor(min(trial1$cum_mean))
if (min_y > .4) min_y = .4
# calculate last mean and standard error
last_mean <- trial1$cum_mean[n]
std_dev <- round(sd(trial1$flips),6)
std_error <- round(sd(trial1$flips)/sqrt(n),6)
# caption
# plot the results together
p <- ggplot(trial1, aes(x=index,y=cum_mean)) +
geom_line(colour = "blue") +
geom_hline(aes(yintercept=0.5,colour="darkorange")) +
theme(plot.title = element_text(size=rel(1.5)),
panel.background = element_rect()) +
labs(title = "Law of Large Numbers\nCoin Tosses\n",
x = "n (number of tosses)",
y = "Cumulative Average") +
scale_y_continuous(limits = c(min_y, max_y)) +
scale_x_continuous(trans = "log10",
breaks = trans_breaks("log10",function(x) 10^x),
labels = trans_format("log10",math_format(10^.x))) +
annotate("text",
label=paste("last =", last_mean,
"\nsd =", std_dev,
"\nse =", std_error),
y=(max_y - .30),
x=n/2, colour="darkgreen")
return(p)
}
ggplotCoinTosses(10000)
ggplotCoinTosses(1000000)
ggplotCoinTosses(1000)
install.packages(c("foreign", "manipulate", "swirl"))
example(anscombe)
data(mtcars)
mean(mtcars_manual$mpg) - mean(mtcars_auto$mpg)
data(mtcars)
mtcars_manual <- mtcars[mtcars$am == 1,]
mtcars_auto <- mtcars[mtcars$am == 0,]
mean(mtcars_manual$mpg) - mean(mtcars_auto$mpg)
?mtcars
data(mtcars)
cor(mtcars)
?bestglm
??bestglm
data(mtcars); n <- length(mtcars$mpg)
fit <- lm(mpg ~ am, data = mtcars)
summary(fit)
plot(resid(fit))
plot(fit)
fit <- lm(mpg ~ am - 1, data = mtcars)
summary(fit)
fit <- lm(mpg ~ am, data = mtcars)
summary(fit)
fit <- lm(mpg ~ factor(am), data = mtcars)
summary(fit)
mean(mtcars$mpg[am == 0,])
mean(mtcars$mpg[mtcars$am == 0,])
mean(mtcars[mtcars$am == 0,]$mpg)
mean(mtcars[mtcars$am == 1,]$mpg)
View(mtcars)
mtc <- data(mtcars)
dim(mtcars)
mtc$am <-  factor(mtc$am, labels=c("Manual", "Auto"))
basemodel<-lm(mpg~am, data=mtc)
fullmodel<-lm(mpg~., data=mtc)
model<-step(fullmodel)
mtc <- data(mtcars)
dim(mtcars)
head(mtcars)
mtc$am <-  factor(mtc$am, labels=c("Manual", "Auto"))
basemodel<-lm(mpg~am, data=mtc)
mtc <- data(mtcars)
dim(mtcars)
head(mtcars)
# mtc$am <-  factor(mtc$am, labels=c("Manual", "Auto"))
basemodel<-lm(mpg~am, data=mtc)
fullmodel<-lm(mpg~., data=mtc)
mtc <- data(mtcars)
basemodel<-lm(mpg~am, data=mtc)
basemodel <- lm(mpg ~ am, data=mtc)
mtc <- data(mtcars)
data(mtcars)
basemodel <- lm(mpg ~ am, data=mtcars)
fullmodel<-lm(mpg~., data=mtcars)
model<-step(fullmodel)
library(bestglm)
ggbiplot(prcomp(mtcars, scale.=TRUE, center=TRUE, data=mtcars),
obs.scale=1, var.scale=1, groups=kmeans(scale(mtcars),3)$cluster,
varname.abbrev=TRUE, ellipse=TRUE, circle=TRUE, labels=rownames(mtcars))+
theme(legend.position="none")
library(ggplot2)
ggbiplot(prcomp(mtcars, scale.=TRUE, center=TRUE, data=mtcars),
obs.scale=1, var.scale=1, groups=kmeans(scale(mtcars),3)$cluster,
varname.abbrev=TRUE, ellipse=TRUE, circle=TRUE, labels=rownames(mtcars))+
theme(legend.position="none")
install.packages("ggbiplot")
133055204 - 114535951
(133055204 - 114535951) / 7
(133055204 - 114535951) / 5
(133055204 - 114535951) / 4.5
20055371 / 5
install.packages("ggbiplot")
library(devtools)
install.packages("devtools")
library(devtools)
install_github("ggbiplot", "vqv")
data(wine)
data(mtcars)
g <- ggbiplot(mtcars, obs.scale = 1, var.scale = 1,
groups = wine.class, ellipse = TRUE, circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + opts(legend.direction = 'horizontal',
legend.position = 'top')
print(g)
g <- ggbiplot(mtcars, obs.scale = 1, var.scale = 1,
groups = wine.class, ellipse = TRUE, circle = TRUE)
library(ggbiplot)
data(mtcars)
g <- ggbiplot(mtcars, obs.scale = 1, var.scale = 1,
groups = wine.class, ellipse = TRUE, circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + opts(legend.direction = 'horizontal',
legend.position = 'top')
print(g)
mtcars.pca <- prcomp(mtcars, scale. = TRUE)
g <- ggbiplot(mtcars.pca, obs.scale = 1, var.scale = 1,
groups = wine.class, ellipse = TRUE, circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + opts(legend.direction = 'horizontal',
legend.position = 'top')
mtcars.pca <- prcomp(mtcars, scale. = TRUE)
g <- ggbiplot(mtcars.pca, obs.scale = 1, var.scale = 1,
groups = mtcars.mpg, ellipse = TRUE, circle = TRUE)
g <- ggbiplot(mtcars.pca, obs.scale = 1, var.scale = 1,
groups = mtcars.class, ellipse = TRUE, circle = TRUE)
g <- ggbiplot(mtcars.pca, obs.scale = 1, var.scale = 1,
ellipse = TRUE, circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + opts(legend.direction = 'horizontal',
legend.position = 'top')
mtcars.pca <- prcomp(mtcars, scale. = TRUE)
g <- ggbiplot(mtcars.pca, obs.scale = 1, var.scale = 1,
ellipse = TRUE, circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top')
print(g)
install.packages(c("boot", "car", "class", "cluster", "Hmisc", "KernSmooth", "manipulate", "nnet", "Rcpp", "rmarkdown", "shiny", "spatial"))
install.packages(c("boot", "car", "class", "cluster", "Hmisc",
install.packages("manipulate")
num <- c(8,9,10,11,12)
mean(num)
median(num)
sd(num)
var(num)
?t.test
library(psych)
describe(num)
library(shiny)
setwd("~/Sites/data-science/r-projects/coursera/devdataproducts/CourseProject")
runApp()
runApp(display.mode = "showcase")
runApp()
